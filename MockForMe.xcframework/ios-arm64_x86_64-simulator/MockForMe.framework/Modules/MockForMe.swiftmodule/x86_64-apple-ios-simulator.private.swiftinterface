// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
// swift-module-flags: -target x86_64-apple-ios18.5-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name MockForMe
// swift-module-flags-ignorable:  -interface-compiler-version 6.1.2
import Combine
import Foundation
import Swift
import SwiftUI
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public enum MFMLog {
  public static func d(_ message: @autoclosure @escaping () -> Swift.String)
}
public struct MFMState : Swift.Sendable {
  public var token: Swift.String
  public var orgId: Swift.String?
  public var memberKey: Swift.String?
  public var memberCacheKey: Swift.String?
  public var mappings: [MockForMe.ApiMapping]
  public var rules: [MockForMe.Rule]
  public var loggingEnabled: Swift.Bool
  public var isInterceptionEnabled: Swift.Bool
  public init(token: Swift.String = "", orgId: Swift.String? = nil, memberKey: Swift.String? = nil, memberCacheKey: Swift.String? = nil, mappings: [MockForMe.ApiMapping] = [], rules: [MockForMe.Rule] = [], loggingEnabled: Swift.Bool = true, isInterceptionEnabled: Swift.Bool = true)
}
@_hasMissingDesignatedInitializers @available(iOS 13.0, *)
public actor MFMEnv {
  public static let shared: MockForMe.MFMEnv
  public func snapshot() -> MockForMe.MFMState
  public func update(_ edit: (inout MockForMe.MFMState) -> Swift.Void)
  public func setToken(_ token: Swift.String)
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
@_hasMissingDesignatedInitializers public class MFMEnvLegacy {
  public static let shared: MockForMe.MFMEnvLegacy
  public func snapshotSync() -> MockForMe.MFMState
  public func updateSync(_ edit: (inout MockForMe.MFMState) -> Swift.Void)
  public func setTokenSync(_ token: Swift.String)
  @objc deinit
}
public class MockForMeCrypto {
  public init()
  public func decrypt(di: Swift.String, iv: Swift.String, orgId: Swift.String) throws -> Swift.String
  @objc deinit
}
public enum MockForMeError : Foundation.LocalizedError, Swift.Equatable {
  case missingToken
  case invalidToken
  case invalidResponse
  case decryptFailed
  case apiError(Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: MockForMe.MockForMeError, b: MockForMe.MockForMeError) -> Swift.Bool
}
public class MockForMeSDK {
  public init(_ token: Swift.String = "")
  public static func reload(onSuccess: @escaping ([MockForMe.ApiMapping], [MockForMe.Rule]) -> Swift.Void = { _, _ in }, onError: @escaping (any Swift.Error) -> Swift.Void = { _ in })
  public func run(onSuccess: @escaping ([MockForMe.ApiMapping], [MockForMe.Rule]) -> Swift.Void = { _, _ in }, onError: @escaping (any Swift.Error) -> Swift.Void = { _ in })
  public static func sendMessage(type: Swift.String, event: Swift.String, payload: [Swift.String : Any])
  @objc deinit
}
final public class mockforme {
  public init(_ token: Swift.String = "")
  final public func run(onSuccess: @escaping ([MockForMe.ApiMapping], [MockForMe.Rule]) -> Swift.Void = { _, _ in }, onError: @escaping (any Swift.Error) -> Swift.Void = { _ in })
  public static func reload(onSuccess: @escaping ([MockForMe.ApiMapping], [MockForMe.Rule]) -> Swift.Void = { _, _ in }, onError: @escaping (any Swift.Error) -> Swift.Void = { _ in })
  public static func sendMessage(type: Swift.String, event: Swift.String, payload: [Swift.String : Any])
  @objc deinit
}
public struct MockForMeDecrypter {
  public static func xorCipher(input: Swift.String, key: Swift.String) -> Swift.String
  public static func decodeBase64(_ input: Swift.String) -> Swift.String?
  public static func decrypt(di: Swift.String, iv: Swift.String, salt: Swift.String) throws -> [[Swift.String : Any]]
}
@_hasMissingDesignatedInitializers @available(iOS 13.0, *)
public class MockForMeOverlay {
  public static let shared: MockForMe.MockForMeOverlay
  public var floatingIconFrame: CoreFoundation.CGRect
  public var isInspectorPresented: Swift.Bool
  public func show()
  public func hide()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers final public class MockForMeURLProtocol : Foundation.URLProtocol {
  @objc override final public class func canInit(with request: Foundation.URLRequest) -> Swift.Bool
  @objc override final public class func canonicalRequest(for request: Foundation.URLRequest) -> Foundation.URLRequest
  @objc override final public func startLoading()
  @objc override final public func stopLoading()
  @objc override dynamic public init(request: Foundation.URLRequest, cachedResponse: Foundation.CachedURLResponse?, client: (any Foundation.URLProtocolClient)?)
  @objc deinit
}
public struct LogEntry : Swift.Identifiable, Swift.Sendable {
  public let id: Foundation.UUID
  public let url: Swift.String
  public let capturedURL: Swift.String
  public let method: Swift.String
  public let status: Swift.Int
  public let timestamp: Foundation.Date
  public let isMocked: Swift.Bool
  public let ruleId: Swift.String?
  public let ruleAction: Swift.String?
  public let errorMessage: Swift.String?
  public let requestHeaders: [Swift.String : Swift.String]?
  public let responseHeaders: [Swift.String : Swift.String]?
  public let requestBody: Swift.String?
  public let responseBody: Swift.String?
  public var statusString: Swift.String {
    get
  }
  public var relativeURL: Swift.String {
    get
  }
  public var displayURL: Swift.String {
    get
  }
  public var requestCookies: [Swift.String : Swift.String] {
    get
  }
  public var responseCookies: [Swift.String : Swift.String] {
    get
  }
  public typealias ID = Foundation.UUID
}
@_hasMissingDesignatedInitializers @available(iOS 13.0, *)
public class NetworkLogger : Foundation.ObservableObject {
  public static let shared: MockForMe.NetworkLogger
  @Combine.Published @_projectedValueProperty($logs) public var logs: [MockForMe.LogEntry] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  public var $logs: Combine.Published<[MockForMe.LogEntry]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  public func addLog(url: Swift.String, capturedURL: Swift.String? = nil, method: Swift.String, status: Swift.Int, isMocked: Swift.Bool, ruleId: Swift.String? = nil, ruleAction: Swift.String? = nil, errorMessage: Swift.String? = nil, requestHeaders: [Swift.String : Swift.String]? = nil, responseHeaders: [Swift.String : Swift.String]? = nil, requestBody: Swift.String? = nil, responseBody: Swift.String? = nil)
  public func clear()
  @available(iOS 13.0, *)
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
public enum NetworkUtil {
  @available(iOS 13.0, *)
  public static func getCompat(url: Foundation.URL, headers: [Swift.String : Swift.String] = [:]) async throws -> (Foundation.Data, Foundation.URLResponse)
  public static func getCompat(url: Foundation.URL, headers: [Swift.String : Swift.String] = [:], completion: @escaping (Swift.Result<(Foundation.Data, Foundation.URLResponse), any Swift.Error>) -> Swift.Void)
}
public struct Rule : Swift.Sendable {
  public enum Action : Swift.Sendable {
    case delay(Foundation.TimeInterval)
    case delayAndRedirect(Foundation.TimeInterval, Swift.String)
    case delayAndTimeout(Foundation.TimeInterval)
  }
  public let id: Swift.String
  public let type: Swift.String
  public let operatorType: Swift.String
  public let value: Swift.String
  public let action: MockForMe.Rule.Action
  public init(id: Swift.String, type: Swift.String, operatorType: Swift.String, value: Swift.String, action: MockForMe.Rule.Action)
}
public struct GatewayDTO : Swift.Codable {
  public let iv: Swift.String?
  public let di: Swift.String?
  public let _o: Swift.String?
  public let mk: Swift.String?
  public let _mck: Swift.String?
  public let r: [MockForMe.RuleDTO]?
  public let mappings: [MockForMe.ApiMapping]?
  public var diData: Foundation.Data? {
    get
  }
  public var ivData: Foundation.Data? {
    get
  }
  public init(iv: Swift.String?, di: Swift.String?, _o: Swift.String?, mk: Swift.String?, _mck: Swift.String?, r: [MockForMe.RuleDTO]?, mappings: [MockForMe.ApiMapping]?)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RuleDTO : Swift.Codable {
  public let _id: Swift.String
  public let rule: MockForMe.RuleEnvelope
  public init(_id: Swift.String, rule: MockForMe.RuleEnvelope)
  public func toDomain() -> MockForMe.Rule
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RuleEnvelope : Swift.Codable {
  public let URL: MockForMe.UrlRule
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct UrlRule : Swift.Codable {
  public let type: Swift.String
  public let condition: MockForMe.RuleCondition
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RuleCondition : Swift.Codable {
  public let key: Swift.String?
  public let operatorType: Swift.String
  public let value: Swift.String
  public let activeAction: Swift.String
  public let actions: MockForMe.RuleActions
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case key
    case operatorType
    case value
    case activeAction
    case actions
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RuleActions : Swift.Codable {
  public let delay: MockForMe.DelayCfg?
  public let delay_and_redirect: MockForMe.DelayRedirectCfg?
  public let delay_and_timeout: MockForMe.DelayCfg?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DelayCfg : Swift.Codable {
  public let value: Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DelayRedirectCfg : Swift.Codable {
  public let value: Swift.Int
  public let redirectUrl: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers @available(iOS 13.0, *)
public actor RulesManager {
  public static let shared: MockForMe.RulesManager
  public func setRules(_ r: [MockForMe.Rule])
  public func all() -> [MockForMe.Rule]
  public func match(urlString: Swift.String) -> MockForMe.Rule?
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
@_hasMissingDesignatedInitializers public class RulesManagerLegacy {
  public static let shared: MockForMe.RulesManagerLegacy
  public func setRulesSync(_ r: [MockForMe.Rule])
  public func allSync() -> [MockForMe.Rule]
  public func matchSync(urlString: Swift.String) -> MockForMe.Rule?
  @objc deinit
}
extension Foundation.URLSession {
  public func dataCompat(for request: Foundation.URLRequest, completion: @escaping (Swift.Result<(Foundation.Data, Foundation.URLResponse), any Swift.Error>) -> Swift.Void)
  @available(iOS 13.0, *)
  public func dataCompat(for request: Foundation.URLRequest) async throws -> (Foundation.Data, Foundation.URLResponse)
}
public struct ApiMapping : Swift.Codable, Swift.Sendable {
  public let apiEndpoint: Swift.String
  public let method: Swift.String?
  public let _ack: Swift.String?
  public let _ri_: Swift.String?
  public init(apiEndpoint: Swift.String, method: Swift.String?, _ack: Swift.String?, _ri_: Swift.String?)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum ApiMatcher {
  public static func match(url: Foundation.URL, method: Swift.String, mappings: [MockForMe.ApiMapping]) -> MockForMe.ApiMapping?
  public static func rewrite(_ request: Foundation.URLRequest, token: Swift.String, memberCacheKey: Swift.String?, match: MockForMe.ApiMapping) -> Foundation.URLRequest
}
extension MockForMe.RuleCondition.CodingKeys : Swift.Equatable {}
extension MockForMe.RuleCondition.CodingKeys : Swift.Hashable {}
extension MockForMe.RuleCondition.CodingKeys : Swift.RawRepresentable {}
